\documentclass[a4paper,10pt]{article}
   
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{xcolor, colortbl}
\usepackage{caption}
\usepackage{listings}
\usepackage{wrapfig} 
\usepackage{tabu} % For coloring single row of table
\usepackage{scrextend}
%\usepackage{hyperref}

\renewcommand\familydefault{\sfdefault} 
\usepackage{tgheros}
\usepackage[defaultmono]{droidmono}

\usepackage{amsmath,amssymb,amsthm,textcomp}
\usepackage{enumerate}
\usepackage{multicol}
\usepackage{tikz}

\usepackage{geometry}
\usepackage{trace}
\usepackage{tcolorbox}
\usepackage{tabularx}
\usepackage{accsupp}% http://ctan.org/pkg/accsupp
\usepackage{enumitem}

%% For using numbers at every level of enumerated list
\newlist{legal}{enumerate}{10}
\setlist[legal]{label*=\arabic*.}

\tcbuselibrary{listings,skins} % For lstlisting

\geometry{total={210mm,297mm},
left=25mm,right=25mm,%
bindingoffset=0mm, top=20mm,bottom=20mm}


% For coloring single row in table
\def\zapcolorreset{\let\reset@color\relax\ignorespaces}
\def\colorrows#1{\noalign{\aftergroup\zapcolorreset#1}\ignorespaces}

\newcommand{\linia}{\rule{\linewidth}{0.5pt}}
\newcommand{\ano}{\text{2}}

% custom theorems if needed
\newtheoremstyle{mytheor}
    {1ex}{1ex}{\normalfont}{0pt}{\scshape}{.}{1ex}
    {{\thmname{#1 }}{\thmnumber{#2}}{\thmnote{ (#3)}}}

\theoremstyle{mytheor}
\newtheorem{defi}{Definition}

%%% Declare title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\antitle}{\text{Verilog Modelling Techniques}}
% my own titles
\makeatletter
\renewcommand{\maketitle}{
\begin{center}
\vspace{2ex}
{\huge \textsc{{{\large}Assignment - \ano}\vspace{0.1cm} \break \antitle}}
\vspace{1ex}
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Department of Electronics and Communication Engineering \\
Indian Institute of Technology, Roorkee
\linia\\
ECN 104 \hfill Digital Logic Design
\vspace{4ex}
\end{center}
}
\makeatother
%%%

% custom footers and headers
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{}
\lfoot{Assignment \ano\ - \antitle}
\cfoot{}
\rfoot{Page \thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
%

\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}

\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{%
    \edef\@temp{\the\lst@token}%
    \ifx\@temp\@lbracket \color{black}%
    \else\ifx\@temp\@rbracket \color{black}%
    \else\ifx\@temp\@colon \color{black}%
    \else \color{vorange}%
    \fi\fi\fi
}
\makeatother

\definecolor{codebg}{RGB}{250,250,240} 
\definecolor{greatblue}{RGB}{91,155,215} 

% Set up caption and labels for lstlistings
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{greatblue}{\parbox{\textwidth}{\hspace{1cm}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\renewcommand{\thelstnumber}{% Line number printing mechanism
  \protect\BeginAccSupp{ActualText={}}\arabic{lstnumber}\protect\EndAccSupp{}%
}

\def\backtick{\char18} 
\lstdefinestyle{verilog-style}
{
    %columns=fullflexible, 
    language=Verilog,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    numbers=left, 
    numberstyle=\color{gray},  
    numbersep=10pt,
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1, 
%    backgroundcolor=\color{codebg},
%    framexrightmargin=0.09cm, 
    framexleftmargin=-0.09cm,
    frame=trbl,
    upquote=true, 
    framerule=0pt,
    keepspaces=true
}

\lstdefinestyle{verilog-inline-style}
{
    language=Verilog,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1, 
    upquote=true, 
    framerule=0pt,
    keepspaces=true
}

\newcommand{
  \insertverilog}[3]{
  \lstinputlisting[label=#2, caption=#3, style={verilog-style}]{#1}
}


% Command for problem
\newcounter{problemNumber}
\setcounter{problemNumber}{1}
\newcommand {
  \insertProblem}[1]{
  \vspace{0.5cm}
  \hrule
  \vspace{0.3cm}

  {\color{greatblue}\textbf{\large{Problem \theproblemNumber}}}
  \vspace{2pt}\\#1

  \addtocounter{problemNumber}{1}
  \vspace{0.2cm}
  \hrule  
  \vspace{0.5cm}
}


%%%----------%%%----------%%%----------%%%----------%%%
% Command for creating a resource box
\newcommand{\resourcebox}[2]{
  \fbox{%
    \parbox{0.5\textwidth}{%
      \text{#1}
    }%
  } 
}


%%%----------%%%----------%%%----------%%%----------%%%

\makeatletter
\def\lst@outputspace{{\ifx\lst@bkgcolor\empty\color{white}\else\lst@bkgcolor\fi\lst@visiblespace}}
\makeatother


%%%----------%%%----------%%%----------%%%----------%%%
\begin{document}

\title{Assignment \ano \\ Modelling Sequential Logic Using Verilog}

\maketitle
\tableofcontents
\section{Introduction}
Verilog supports wide variety of modelling techniques. Different
modelling techniques allows writing hardware description at different
levels of abstraction, starting from the switch level modelling
(PMOS/NMOS) and all the way up to behavioural modelling (algorithmic
description). Each one of them have their own benefits and use
cases. In this assignment we will discuss three of them, namely
Gate-level modelling, structural modelling and behavioural modelling.

\section{Gate-level modelling}
Gate-level modelling in Verilog is used to describe a circuit only
using logic gates. This approach is used to describe critical parts of
a design, like adders and multipliers. Using gate-level implementation
allows greater control over the design than other
techniques. Gate-level modelling is only used for small scale design,
due to its complexity other modelling techniques are commonly used to
abstract gate level implementations.

\subsection{Gate Primitives in Verilog}
Verilog support following gates:
\begin{multicols}{2}
  \begin{itemize}
  \item AND
  \item NAND
  \item OR
  \item NOR
  \item XOR
  \item XNOR
  \item NOT
  \end{itemize}
\end{multicols}


Gates in Verilog are available as primitives and can be instantiated
similar to modules, Listing \ref{gate-level-impl} is an example gate
level circuit.

\insertverilog{./verilog_files/gateLevelExample.v}{gate-level-impl}{\text{Example module using Gate-level modelling}}

Verilog also supports instantiating gates without a instance name
demonstrated in Listing \ref{gate-instance-without-name}.
\insertverilog{./verilog_files/unnamedGate.v}{gate-instance-without-name}{\text{Instantiating unnamed gates}}

\subsection{Delay specification}
All the circuits we have studied so far have no delay associated with
them, these are called 0-delay circuits. Real circuits however, always
have a delay between their input and output. Verilog allows modelling
of delays at various level of abstraction using delay statements.

Syntax for specifying a delay is:
\begin{lstlisting}[style=verilog-inline-style, xleftmargin=0.2\textwidth]
  <gate_primitive> #(<delay>) <inst_name>(...ports...) 
\end{lstlisting}

For example:
\begin{lstlisting}[style=verilog-inline-style, xleftmargin=0.25\textwidth]
  /* 2-input AND gate with 1 time unit delay */
  and #(1) a1(result, input1, input2);
\end{lstlisting}

\vspace{0.1cm}
To specify unit of delay we'll write a compiler
directive, this is typically written at the begining of the
description.

\begin{center}
  \begin{lstlisting}[style=verilog-inline-style,xleftmargin=.35\textwidth]
    `timescale 1ns/1ps
  \end{lstlisting}
\end{center}


Here \lstinline[upquote=true]{1ns} is the time unit while
\lstinline[upquote=true]{1ps} is the time resolution. Which will be
explained in later assignment. A complete example using delay
statements is given in Listing \ref{delay-example}.

\insertverilog{./verilog_files/delayExample.v}{delay-example}{\text{Example usage of delays statement to specify propagation delay of logic gates.}}

\insertProblem { NOT gate is one of the primitives available with
  Verilog, NOT gate is a type of buffer and is also known as inverting
  buffer. Buffers in digital circuit are often used to isolate two
  parts of a circuit, but this isolation can also be added with a
  certain behaviour like inversion of signal or delaying signal to
  synchronize with other parts.
  
  \begin {enumerate}
  \item Write a Verilog module which acts as an inverting buffer (that
    is, a NOT gate), you have to use verilog primitive
    \lstinline[style=verilog-inline-style]{not} for the
    implementation, use the testbench
    \textsc{testbench{\ano}.{\theproblemNumber}.1.v} for testing your
    design.
  \item Another kind of buffer often used in digital circuit is the
    `non-inverting buffer'. As the name suggests, the non-inverting
    buffer doesn't invert the input unlike the inverting buffer. This
    buffer seems to be of no use since it cannot do any
    processing. This leads us to its one of the common use case, using
    buffer to level translation. Level translation is used whenever
    two parts of a circuit are powered with different Vdd (different
    supply voltages). Now that you know what a buffer is, write a
    Verilog module to implement a buffer using the inverting buffers
    you designed in Problem {\theproblemNumber}.1.
  \item NOT gates are also used in ring oscillators, which is a kind
    of an oscillator often used to generate clock signals. Ring
    oscillator is an oscillator which looks like a ring, and contains
    a chain of odd number of NOT gates. Ring oscillator's frequency
    depends on the delay of the NOT gate and number of gates used. A
    simple 3 NOT gate ring oscillator is shown in
    Fig. \ref{ring-oscillator}. Let the propagation delay of each of
    the gate in Fig. \ref{ring-oscillator} be $t_d$, intuitively one
    can say that the delay between change of values at any point is
    $3t_d$. Use this information and calculate the time period of an n
    NOT gate ring oscillator, where n is an odd number.

    \begin{figure}[!h] \centering  
      \includegraphics[width=0.5\linewidth]{./resources/ringOscillator.pdf}
      \caption{Simulation result for Listing \ref{ring-oscillator}, output changes 15ns after the change in input.} 
      \label{ring-oscillator}
    \end{figure}

  \item Using the expression from the Problem {\theproblemNumber}.3,
    write the description of a module for a 5 NOT gate ring
    oscillator. You have to design the ring oscillator such that the
    time period of the generated wave will be 30ns, assume that each
    of the NOT gate has a propagation delay of 5ns.

  \item Using the expression from the Problem {\theproblemNumber}.3,
    write the description of a module for a 5 NOT gate ring
    oscillator. You have to design the ring oscillator such that the
    time period of the generated wave should be 30ns, assume that each
    of the NOT gate has a propagation delay of 5ns.
  \item Will a single not gate ring oscillator work? Why or why not?
  \end{enumerate}
} 


\section{Data-flow Modelling}
%https://stackoverflow.com/questions/28751979/difference-between-behavioral-and-dataflow-in-verilog#28759581
Data flow modelling is a higher level of abstraction than the gate
level modelling we just studied. Describing a circuit using data-flow
modelling does not require knowledge of gates level circuit, thus it
is easier than gate-level modelling when description of large scale
circuits are written.  All the examples from Assignment 1 used data
flow modelling.

\subsection{Continuous Assignment}
\label{continuous-assignment}
Continuous assignment in Verilog are used for data flow modelling,
these assignment starts with
\lstinline[style=verilog-inline-style]{assign} keyword. Continuous
assignment drives value into a net
(\lstinline[style=verilog-inline-style]{wire}). Following example
describes use of continuous assignment:

{\color{red}\textbf{Note:}} Verilog is concurrent language unlike
programming languages such as C,C++ or Java. All the continuous
assignments are evaluated at the same time.

\insertverilog{./verilog_files/continuousAssignment.v}{continuous-assignment}{Example usage of continuous assignment.}

Continuous assigment in Verilog can also be done implicitly, which is
assigning value on declaration of a net
(\lstinline[style=verilog-inline-style]{wire}). Implicit delcaration
of Verilog is:
\begin{lstlisting}[style=verilog-inline-style,xleftmargin=.25\textwidth]
  wire new_wire = input1 & input2;
\end{lstlisting}

\subsection{Assignment Delays}
Similar to gate-level modelling, Verilog allows specifying delays in
assignment to model real circuits. Assignment delay specify the delay
between the change of LHS and RHS of a continuous assignment. Listing
\ref{assignment-delay} shows example usage of assignment delay while
Fig. \ref{assignment-delay-sim} shows simulation result of Listing
\ref{assignment-delay}.

\insertverilog{./verilog_files/assignmentDelay.v}{assignment-delay}{Using assignment delay in Verilog.}

\begin{figure}[!h] \centering  
  \includegraphics[width=0.8\linewidth]{./resources/assignmentDelay.png}
  \caption{Simulation result for Listing \ref{assignment-delay}, output changes 15ns after the change in input.} 
  \label{assignment-delay-sim}
\end{figure}

\pagebreak
\insertProblem { Multiplexer is a digital element which is used to
  select a single signal from a group of signals. Block diagram of a
  multiplexer is shown in Fig. \ref{multiplexer}, the input
  $\text{in}_1$ and $\text{in}_2$ are multiplexed and the output is
  decided using the input $\text{c}$. If the input c is 0 then
  $\text{output}=\text{in}_1$ else $\text{output}=\text{in}_2$.
  
  \begin{figure}[!h] \centering  
    \includegraphics[width=0.3\linewidth]{./resources/multiplexer.pdf} 
    \caption{Simulation result for Listing \ref{assignment-delay}, output changes 15ns after the change in input.} 
    \label{multiplexer} 
  \end{figure}

  \begin{enumerate}
    
  \item Write the hardware description of a 2-to-1 multiplexer using
    Verilog, you have to implement this using only data-flow
    modelling. (\textit{Hint: Verilog supports the ternary operator,
      which has same behaviour as in programming languages.})
  \item Now suppose you want to model a multiplexer you just purchased
    from the market, which has a propagation delay of 2ns. Modify the
    module from part 1 such that the behaviour of your description
    matches the one you bought.
}
\section{Behavioral Modelling}
Behavioral modelling is an even higher level of modelling where
circuit description is written as its behaviour, this algorithmic
representation of a circuit abstracts the details of gate-level and
data flow modelling. Behavioral modelling resembles more to
programming languages such as C than it does to circuit description.


\subsection{\lstinline[style=verilog-inline-style]{reg} Element}
\lstinline[style=verilog-inline-style]{reg} element is used to
represent abstract storage device in
Verilog. \lstinline[style=verilog-inline-style]{reg}s can be used to
store information (single bit or of arbitrary length using
array, arrays are similar to vectors). We'll get back to usage of
\lstinline[style=verilog-inline-style]{reg} and will differentiate it
with \lstinline[style=verilog-inline-style]{wire} after studying
procedural blocks.

\subsection{Procedural Blocks}
Earlier we read about continuous assignment which allows us to drive
value to a net whenever the driver changes, this kind of assignment
allows only to describe combinational circuit. To describe sequential
circuits Verilog provides procedural blocks, these blocks are used to
drive values to net (\lstinline[style=verilog-inline-style]{reg}) only
inf the condition is met.

\subsection{\lstinline[style=verilog-inline-style]{initial} Block}
\lstinline[style=verilog-inline-style]{Initial} blocks in Verilog are
used to specify initial values of all the storage elements. When
simulation starts simulator doesn't know what values are to be
assigned to storage elements. Initial block begins with
\lstinline[style=verilog-inline-style]{initial begin} and ends with
\lstinline[style=verilog-inline-style]{end}. Initial blocks gets
executed only once when the simulation is started.

{\color{red}\textbf{Note:}} Only a
\lstinline[style=verilog-inline-style]{reg} can be assigned values
inside an \lstinline[style=verilog-inline-style]{initial} block, this
is because unlike \lstinline[style=verilog-inline-style]{wire} which
are used for connection \lstinline[style=verilog-inline-style]{reg}
stores information and this information is unknown to the simulator at
t=0. Structure of an initial block is given in Listing \ref{initial-structure}.

\insertverilog{./verilog_files/initialStructure.v}{initial-structure}{Structure of an initial block.} 

\subsection{\lstinline[style=verilog-inline-style]{always@} block}
\lstinline[style=verilog-inline-style]{always@} block in Verilog are
used for describing a event which should happen only under certain
conditions, such as change in value of one of the elements.
 
Basic structure of an \lstinline[style=verilog-inline-style]{always@}
block is given in Listing \ref{always-structure}.

\insertverilog{./verilog_files/alwaysStructure.v}{always-structure}{Structure of an always@ block.} 

Listing \ref{always-example} shows a module which changes output only
one the positive edge of input
\lstinline[style=verilog-inline-style]{clk}. 

\insertverilog{./verilog_files/alwaysExample.v}{always-example}{Synchronous logic which changes value of result only at the positive edge of clk.} 
 
\subsection{Blocking and Non-Blocking Assignment}
\subsubsection{Blocking Assignments}
Blocking assingments are assignments which block the simulation while
their value is being calculated. This means that the execution flow
will stop at this statement until it is executed. Blocking assignment
in Verilog is done using
\lstinline[style=verilog-inline-style]{=}. Listing
\ref{non-working-blocking-assignment} demonstrates the functioning of
blocking assignment.

\insertverilog{./verilog_files/nonWorkingSwap.v}{non-working-blocking-assignment}{Swapping bytes using blocking assignment.}  

In the above example (Listing \ref{non-working-blocking-assignment})
statement 18 doesn't gets executed until statement 17 is executed,
this is due to the use of blocking assignment.

\subsubsection{Non-blocking Assignments} 
In Listing \ref{non-working-blocking-assignment} we saw that blocking
assignments cannot be used to swap bytes, this is where non-blocking
assignments will come to use. Non-blocking assignments are evaluated
in two steps first all the RHS values are calculated at the begining
of the procedural block, and then the value is assigned to LHS when
the execution reaches particular statement.

Listing \ref{working-swap} shows how non-blocking assignments can be
used for swapping bytes.

\insertverilog{./verilog_files/workingSwap.v}{working-swap}{Swapping bytes using non-blocking assignment\, it works!}   

\section{Differences between \lstinline[style=verilog-inline-style]{wire} and \lstinline[style=verilog-inline-style]{reg} and where to use what}
\subsection{Legal use of \lstinline[style=verilog-inline-style]{wire}}
Wires in Verilog are used to connect two elements, they can be
assigned a value or a value can be read from them. However they cannot
store it, you'll have to drive them with values (constant, other wires
or regs).

\begin{itemize}
\item \lstinline[style=verilog-inline-style]{wire}s are allowed only
  in continuous assignments (page \pageref{continuous-assignment}).
\item A \lstinline[style=verilog-inline-style]{wire} cannot be
  assigned a value inside a procedural block.
\item A \lstinline[style=verilog-inline-style]{wire} can be used to
  assign a value to a \lstinline[style=verilog-inline-style]{reg} or a
  \lstinline[style=verilog-inline-style]{wire}.
\item \lstinline[style=verilog-inline-style]{wire}s can be used for I/O connections of a module instance.
\end{itemize}

\subsection{Legal use of \lstinline[style=verilog-inline-style]{reg}}
\lstinline[style=verilog-inline-style]{reg}s in Verilog are storage
elements, they however do not represent physical registers. Once
synthesized they can be represented by a physical register, RAM or
ROM.

 \begin{itemize}
 \item \lstinline[style=verilog-inline-style]{reg}s cannot be assigned
   a value using continuous assigment.
 \item A \lstinline[style=verilog-inline-style]{reg} can only be
   assigned a value in a procedural block.
 \item A \lstinline[style=verilog-inline-style]{reg} can be used to
   assign a value to a \lstinline[style=verilog-inline-style]{reg} or
   a \lstinline[style=verilog-inline-style]{wire}.
\end{itemize}

 \subsection{Places where both \lstinline[style=verilog-inline-style]{wire} and \lstinline[style=verilog-inline-style]{reg} are allowed}

 \begin{itemize}
 \item Both can appear on the right hand side of an \lstinline[style=verilog-inline-style]{assign} statement or can be used inside a procedural block (\lstinline[style=verilog-inline-style]{initial}/\lstinline[style=verilog-inline-style]{always}) block to set value of a \lstinline[style=verilog-inline-style]{reg}.
 \item Can be used as inputs to a module.
\end{itemize}

 % Link to java implementation of turing machines: https://introcs.cs.princeton.edu/java/52turing/

 \insertProblem { A Turing machines is a theoretical machine which is
   used as an abstraction to real computational machines, Turing
   machine was proposed by Alan Turing in 1936. The basis of invention
   of turing machine was Alan's interest in the philosophy of
   computation. An interesting thing about the Turing machine is that
   any algorithm which is impossible to implement on Turing machine
   has never worked on any other real machine. Programming languages
   such as Java, C, C++ etc. are said to be turing complete, this
   implies that anything that can be computed by a turing machine can
   be computed by these languages.

   \textbf{Basics of Turing machine}\\ Turing machine consist of an
   infinitely long tape which has certain shapes (or characters) on
   it, this tape is traversed by a head which reads the character
   directly under it and takes appropriate movement decision. An
   example of such machine is shown in
   Fig. \ref{Fig:turing-machine-example}.

   The video at \textsc{https://www.youtube.com/watch?v=mPec64RUCsk}
   will help you understand the Turing machine a bit better.

  \begin{figure}[!h] \centering  
    \includegraphics[width=0.3\linewidth]{./resources/multiplexer.pdf} 
    \caption{Example of a Turing machine.} 
    \label{Fig:turing-machine-example} 
  \end{figure}

  Turing machines can be used to implement Fine state machines, to use
  a Turing machine as a finite state machine we need following
  assumptions:
  \begin{enumerate}
  \item We have a finite length tape (since it would be impossible
    to write description of an infinite tape).
  \item Each character on the tape can only be `A', `+' or `\_' where
    `A' and `+' are used for decisions while `\_' represents a
    halting condition.
  \item The input to the machine will be the initial configuration
    of the tape while the output of the machine will be the state of
    the tape when the machine halts.
  \item At every clock cycle the Turing machine can execute only one
    instruction.
  \item Each instruction execution changes decides the next position
    of the head and can write to the tape where the head is.
  \item Here each possible arrangement of characters on the tape
    represents a single state in the FSM.
  \item The Turing machine stops or in other words the execution stops
    whenever the head reaches a certain state.
  \end{enumerate}

    Now consider the above mentioned Turing machine rules, for a machines
    which adds up two numbers. These numbers are represented in base 1
    ($1111_1$ to represent $4_{10}$):
    \begin{table}
      \centering
      \renewcommand{\arraystretch}{1.1}
      \begin{tabularx}{0.8\textwidth}{|X|X|X|}
        \hline
        \rowcolor{greatblue}
        \color{white} Value under head & \color{white}Direction of movement & \color{white}Write value \\
        \hline
        \vspace{0.2cm}&&\\
        A & Right & - \\
        + & Right & A \\
        \hline
      \end{tabularx}
    \end{table}

    Using this rule set addition of two numbers can be performed, say
    for example you want to add $2_{10}$ ($AA_1$) and $4_{10}$
    ($AAAA_1$) the trace of the Turing machine to perform such
    addition would be (Assuming the halting condition to be a state
    where head returns to the position one left to the first number):
    \begin{legal}
    \item \begin{textsc}\_\_[A]A+AAAA\_\_\_\end{textsc}
    \item \begin{textsc}\_\_A[A]+AAAA\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AA[+]AAAA\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AAA[A]AAA\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AAAA[A]AA\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AAAAA[A]A\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AAAAAA[A]\_\_\_\end{textsc}
      
    \item \begin{textsc}\_\_AAAAA[A]\_\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AAAA[A]A\_\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AAA[A]AA\_\_\_\_\end{textsc}
    \item \begin{textsc}\_\_AA[A]AAA\_\_\_\_\end{textsc}
    \item \begin{textsc}\_\_A[A]AAAA\_\_\_\_\end{textsc}
    \item \begin{textsc}\_\_[A]AAAAA\_\_\_\_\end{textsc}
    \item \begin{textsc}\_[\_]AAAAAA\_\_\_\_\end{textsc} (\textbf{HALT})
    \end{legal}

    Here \textsc{[.]} represents the head of the machine.
    
    \textbf{Questions}
    \begin{legal}
    \item Briefly describe the algorithm for the addition of which the
      trace is give above.
    \item Write Verilog description for the Turing machine described
      above, use 2 bit registers to represent a single location on the
      tape. The tape of the machine will be finite in length and
      should be enough to store the above example.
    \item Simulate the addition of 2 and 4 in the above turing
      machine.
    \end{legal}
  If you want to read more about Turing Machines, you can look up for
  `The halting problem' on the internet.
  
 }

 \pagebreak
\section*{References}
\begin{itemize}
  \small
% https://electronics.stackexchange.com/questions/29553/how-are-verilog-always-statements-implemented-in-hardware
\item
  http://inst.eecs.berkeley.edu/{\textasciitilde}cs150/fa08/Documents/Always.pdf
\item Aenean in sem ac leo mollis blandit.
\end{itemize}

\section*{Additional resources}
\begin{itemize}
  \small 
\item Stack Exchange: How are Verilog “always” statements implemented
  in hardware? \\\textit{http://bit.ly/verilogAlwaysStatement}
\item Stack Overflow: Difference between behavioral and dataflow in
  verilog \\\textit{http://bit.ly/modellingDiff}
\item Stack Overflow: How can I know if my code is synthesizable?
  [Verilog] \\\textit{http://bit.ly/synthCode}
\end{itemize} 

\centerline{\textit{These resources are great for expanding your
    understanding, but...}}
\begin{centering}
  \begin{figure}[!h] \centering  
    \includegraphics[width=0.5\linewidth]{./resources/meme.jpeg} 
  \end{figure}  
\end{centering}

\end{document}

